{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _globalErrorHandlers = require('./globalErrorHandlers');\n\nvar _types = require('./types');\n\nvar _utils = require('./utils');\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now; // TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error\n\nconst eventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result':\n      {\n        state.includeTestLocationInResult = true;\n        break;\n      }\n\n    case 'hook_start':\n      {\n        event.hook.seenDone = false;\n        break;\n      }\n\n    case 'start_describe_definition':\n      {\n        const {\n          blockName,\n          mode\n        } = event;\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest\n        } = state;\n\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        }\n\n        const describeBlock = (0, _utils.makeDescribe)(blockName, currentDescribeBlock, mode);\n        currentDescribeBlock.children.push(describeBlock);\n        state.currentDescribeBlock = describeBlock;\n        break;\n      }\n\n    case 'finish_describe_definition':\n      {\n        const {\n          currentDescribeBlock\n        } = state;\n        (0, _utils.invariant)(currentDescribeBlock, `currentDescribeBlock must be there`);\n\n        if (!(0, _utils.describeBlockHasTests)(currentDescribeBlock)) {\n          currentDescribeBlock.hooks.forEach(hook => {\n            hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n            state.unhandledErrors.push(hook.asyncError);\n          });\n        } // pass mode of currentDescribeBlock to tests\n        // but do not when there is already a single test with \"only\" mode\n\n\n        const shouldPassMode = !(currentDescribeBlock.mode === 'only' && currentDescribeBlock.children.some(child => child.type === 'test' && child.mode === 'only'));\n\n        if (shouldPassMode) {\n          currentDescribeBlock.children.forEach(child => {\n            if (child.type === 'test' && !child.mode) {\n              child.mode = currentDescribeBlock.mode;\n            }\n          });\n        }\n\n        if (!state.hasFocusedTests && currentDescribeBlock.mode !== 'skip' && currentDescribeBlock.children.some(child => child.type === 'test' && child.mode === 'only')) {\n          state.hasFocusedTests = true;\n        }\n\n        if (currentDescribeBlock.parent) {\n          state.currentDescribeBlock = currentDescribeBlock.parent;\n        }\n\n        break;\n      }\n\n    case 'add_hook':\n      {\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest,\n          hasStarted\n        } = state;\n        const {\n          asyncError,\n          fn,\n          hookType: type,\n          timeout\n        } = event;\n\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        } else if (hasStarted) {\n          state.unhandledErrors.push(new Error('Cannot add a hook after tests have started running. Hooks must be defined synchronously.'));\n          break;\n        }\n\n        const parent = currentDescribeBlock;\n        currentDescribeBlock.hooks.push({\n          asyncError,\n          fn,\n          parent,\n          seenDone: false,\n          timeout,\n          type\n        });\n        break;\n      }\n\n    case 'add_test':\n      {\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest,\n          hasStarted\n        } = state;\n        const {\n          asyncError,\n          fn,\n          mode,\n          testName: name,\n          timeout\n        } = event;\n\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        } else if (hasStarted) {\n          state.unhandledErrors.push(new Error('Cannot add a test after tests have started running. Tests must be defined synchronously.'));\n          break;\n        }\n\n        const test = (0, _utils.makeTest)(fn, mode, name, currentDescribeBlock, timeout, asyncError);\n\n        if (currentDescribeBlock.mode !== 'skip' && test.mode === 'only') {\n          state.hasFocusedTests = true;\n        }\n\n        currentDescribeBlock.children.push(test);\n        currentDescribeBlock.tests.push(test);\n        break;\n      }\n\n    case 'hook_failure':\n      {\n        const {\n          test,\n          describeBlock,\n          error,\n          hook\n        } = event;\n        const {\n          asyncError,\n          type\n        } = hook;\n\n        if (type === 'beforeAll') {\n          (0, _utils.invariant)(describeBlock, 'always present for `*All` hooks');\n          (0, _utils.addErrorToEachTestUnderDescribe)(describeBlock, error, asyncError);\n        } else if (type === 'afterAll') {\n          // Attaching `afterAll` errors to each test makes execution flow\n          // too complicated, so we'll consider them to be global.\n          state.unhandledErrors.push([error, asyncError]);\n        } else {\n          (0, _utils.invariant)(test, 'always present for `*Each` hooks');\n          test.errors.push([error, asyncError]);\n        }\n\n        break;\n      }\n\n    case 'test_skip':\n      {\n        event.test.status = 'skip';\n        break;\n      }\n\n    case 'test_todo':\n      {\n        event.test.status = 'todo';\n        break;\n      }\n\n    case 'test_done':\n      {\n        event.test.duration = (0, _utils.getTestDuration)(event.test);\n        event.test.status = 'done';\n        state.currentlyRunningTest = null;\n        break;\n      }\n\n    case 'test_start':\n      {\n        state.currentlyRunningTest = event.test;\n        event.test.startedAt = jestNow();\n        event.test.invocations += 1;\n        break;\n      }\n\n    case 'test_fn_start':\n      {\n        event.test.seenDone = false;\n        break;\n      }\n\n    case 'test_fn_failure':\n      {\n        const {\n          error,\n          test: {\n            asyncError\n          }\n        } = event;\n        event.test.errors.push([error, asyncError]);\n        break;\n      }\n\n    case 'test_retry':\n      {\n        event.test.errors = [];\n        break;\n      }\n\n    case 'run_start':\n      {\n        state.hasStarted = true;\n        global[_types.TEST_TIMEOUT_SYMBOL] && (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);\n        break;\n      }\n\n    case 'run_finish':\n      {\n        break;\n      }\n\n    case 'setup':\n      {\n        // Uncaught exception handlers should be defined on the parent process\n        // object. If defined on the VM's process object they just no op and let\n        // the parent process crash. It might make sense to return a `dispatch`\n        // function to the parent process and register handlers there instead, but\n        // i'm not sure if this is works. For now i just replicated whatever\n        // jasmine was doing -- dabramov\n        state.parentProcess = event.parentProcess;\n        (0, _utils.invariant)(state.parentProcess);\n        state.originalGlobalErrorHandlers = (0, _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);\n\n        if (event.testNamePattern) {\n          state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n        }\n\n        break;\n      }\n\n    case 'teardown':\n      {\n        (0, _utils.invariant)(state.originalGlobalErrorHandlers);\n        (0, _utils.invariant)(state.parentProcess);\n        (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(state.parentProcess, state.originalGlobalErrorHandlers);\n        break;\n      }\n\n    case 'error':\n      {\n        // It's very likely for long-running async tests to throw errors. In this\n        // case we want to catch them and fail the current test. At the same time\n        // there's a possibility that one test sets a long timeout, that will\n        // eventually throw after this test finishes but during some other test\n        // execution, which will result in one test's error failing another test.\n        // In any way, it should be possible to track where the error was thrown\n        // from.\n        state.currentlyRunningTest ? state.currentlyRunningTest.errors.push(event.error) : state.unhandledErrors.push(event.error);\n        break;\n      }\n  }\n};\n\nvar _default = eventHandler;\nexports.default = _default;","map":{"version":3,"sources":["/Users/awaraamin/2020/The-complete-2020-Web-Development-Bootcamp/practice/react/amazona/frontend/node_modules/jest-circus/build/eventHandler.js"],"names":["Object","defineProperty","exports","value","default","_globalErrorHandlers","require","_types","_utils","global","globalThis","self","window","Function","Symbol","jestNow","for","Date","now","eventHandler","event","state","name","includeTestLocationInResult","hook","seenDone","blockName","mode","currentDescribeBlock","currentlyRunningTest","errors","push","Error","describeBlock","makeDescribe","children","invariant","describeBlockHasTests","hooks","forEach","asyncError","message","type","unhandledErrors","shouldPassMode","some","child","hasFocusedTests","parent","hasStarted","fn","hookType","timeout","testName","test","makeTest","tests","error","addErrorToEachTestUnderDescribe","status","duration","getTestDuration","startedAt","invocations","TEST_TIMEOUT_SYMBOL","testTimeout","parentProcess","originalGlobalErrorHandlers","injectGlobalErrorHandlers","testNamePattern","RegExp","restoreGlobalErrorHandlers","_default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _globalErrorHandlers = require('./globalErrorHandlers');\n\nvar _types = require('./types');\n\nvar _utils = require('./utils');\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\n\n// TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error\nconst eventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result': {\n      state.includeTestLocationInResult = true;\n      break;\n    }\n\n    case 'hook_start': {\n      event.hook.seenDone = false;\n      break;\n    }\n\n    case 'start_describe_definition': {\n      const {blockName, mode} = event;\n      const {currentDescribeBlock, currentlyRunningTest} = state;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      }\n\n      const describeBlock = (0, _utils.makeDescribe)(\n        blockName,\n        currentDescribeBlock,\n        mode\n      );\n      currentDescribeBlock.children.push(describeBlock);\n      state.currentDescribeBlock = describeBlock;\n      break;\n    }\n\n    case 'finish_describe_definition': {\n      const {currentDescribeBlock} = state;\n      (0, _utils.invariant)(\n        currentDescribeBlock,\n        `currentDescribeBlock must be there`\n      );\n\n      if (!(0, _utils.describeBlockHasTests)(currentDescribeBlock)) {\n        currentDescribeBlock.hooks.forEach(hook => {\n          hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n          state.unhandledErrors.push(hook.asyncError);\n        });\n      } // pass mode of currentDescribeBlock to tests\n      // but do not when there is already a single test with \"only\" mode\n\n      const shouldPassMode = !(\n        currentDescribeBlock.mode === 'only' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only'\n        )\n      );\n\n      if (shouldPassMode) {\n        currentDescribeBlock.children.forEach(child => {\n          if (child.type === 'test' && !child.mode) {\n            child.mode = currentDescribeBlock.mode;\n          }\n        });\n      }\n\n      if (\n        !state.hasFocusedTests &&\n        currentDescribeBlock.mode !== 'skip' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only'\n        )\n      ) {\n        state.hasFocusedTests = true;\n      }\n\n      if (currentDescribeBlock.parent) {\n        state.currentDescribeBlock = currentDescribeBlock.parent;\n      }\n\n      break;\n    }\n\n    case 'add_hook': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, hookType: type, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a hook after tests have started running. Hooks must be defined synchronously.'\n          )\n        );\n        break;\n      }\n\n      const parent = currentDescribeBlock;\n      currentDescribeBlock.hooks.push({\n        asyncError,\n        fn,\n        parent,\n        seenDone: false,\n        timeout,\n        type\n      });\n      break;\n    }\n\n    case 'add_test': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, mode, testName: name, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a test after tests have started running. Tests must be defined synchronously.'\n          )\n        );\n        break;\n      }\n\n      const test = (0, _utils.makeTest)(\n        fn,\n        mode,\n        name,\n        currentDescribeBlock,\n        timeout,\n        asyncError\n      );\n\n      if (currentDescribeBlock.mode !== 'skip' && test.mode === 'only') {\n        state.hasFocusedTests = true;\n      }\n\n      currentDescribeBlock.children.push(test);\n      currentDescribeBlock.tests.push(test);\n      break;\n    }\n\n    case 'hook_failure': {\n      const {test, describeBlock, error, hook} = event;\n      const {asyncError, type} = hook;\n\n      if (type === 'beforeAll') {\n        (0, _utils.invariant)(describeBlock, 'always present for `*All` hooks');\n        (0, _utils.addErrorToEachTestUnderDescribe)(\n          describeBlock,\n          error,\n          asyncError\n        );\n      } else if (type === 'afterAll') {\n        // Attaching `afterAll` errors to each test makes execution flow\n        // too complicated, so we'll consider them to be global.\n        state.unhandledErrors.push([error, asyncError]);\n      } else {\n        (0, _utils.invariant)(test, 'always present for `*Each` hooks');\n        test.errors.push([error, asyncError]);\n      }\n\n      break;\n    }\n\n    case 'test_skip': {\n      event.test.status = 'skip';\n      break;\n    }\n\n    case 'test_todo': {\n      event.test.status = 'todo';\n      break;\n    }\n\n    case 'test_done': {\n      event.test.duration = (0, _utils.getTestDuration)(event.test);\n      event.test.status = 'done';\n      state.currentlyRunningTest = null;\n      break;\n    }\n\n    case 'test_start': {\n      state.currentlyRunningTest = event.test;\n      event.test.startedAt = jestNow();\n      event.test.invocations += 1;\n      break;\n    }\n\n    case 'test_fn_start': {\n      event.test.seenDone = false;\n      break;\n    }\n\n    case 'test_fn_failure': {\n      const {\n        error,\n        test: {asyncError}\n      } = event;\n      event.test.errors.push([error, asyncError]);\n      break;\n    }\n\n    case 'test_retry': {\n      event.test.errors = [];\n      break;\n    }\n\n    case 'run_start': {\n      state.hasStarted = true;\n      global[_types.TEST_TIMEOUT_SYMBOL] &&\n        (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);\n      break;\n    }\n\n    case 'run_finish': {\n      break;\n    }\n\n    case 'setup': {\n      // Uncaught exception handlers should be defined on the parent process\n      // object. If defined on the VM's process object they just no op and let\n      // the parent process crash. It might make sense to return a `dispatch`\n      // function to the parent process and register handlers there instead, but\n      // i'm not sure if this is works. For now i just replicated whatever\n      // jasmine was doing -- dabramov\n      state.parentProcess = event.parentProcess;\n      (0, _utils.invariant)(state.parentProcess);\n      state.originalGlobalErrorHandlers = (0,\n      _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);\n\n      if (event.testNamePattern) {\n        state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n      }\n\n      break;\n    }\n\n    case 'teardown': {\n      (0, _utils.invariant)(state.originalGlobalErrorHandlers);\n      (0, _utils.invariant)(state.parentProcess);\n      (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(\n        state.parentProcess,\n        state.originalGlobalErrorHandlers\n      );\n      break;\n    }\n\n    case 'error': {\n      // It's very likely for long-running async tests to throw errors. In this\n      // case we want to catch them and fail the current test. At the same time\n      // there's a possibility that one test sets a long timeout, that will\n      // eventually throw after this test finishes but during some other test\n      // execution, which will result in one test's error failing another test.\n      // In any way, it should be possible to track where the error was thrown\n      // from.\n      state.currentlyRunningTest\n        ? state.currentlyRunningTest.errors.push(event.error)\n        : state.unhandledErrors.push(event.error);\n      break;\n    }\n  }\n};\n\nvar _default = eventHandler;\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}