{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getTestID = exports.getTestDuration = exports.getEachHooksForTest = exports.getAllHooksForDescribe = exports.describeBlockHasTests = exports.callAsyncCircusFn = exports.addErrorToEachTestUnderDescribe = void 0;\nexports.invariant = invariant;\nexports.parseSingleTestResult = exports.makeTest = exports.makeSingleTestResult = exports.makeRunResult = exports.makeDescribe = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _dedent = _interopRequireDefault(require('dedent'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _jestUtil = require('jest-util');\n\nvar _prettyFormat = require('pretty-format');\n\nvar _state = require('./state');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\nconst stackUtils = new _stackUtils.default({\n  cwd: 'A path that does not exist'\n});\nconst jestEachBuildDir = (0, _slash.default)(path.dirname(require.resolve('jest-each')));\n\nfunction takesDoneCallback(fn) {\n  return fn.length > 0;\n}\n\nfunction isGeneratorFunction(fn) {\n  return (0, _isGeneratorFn.default)(fn);\n}\n\nconst makeDescribe = (name, parent, mode) => {\n  let _mode = mode;\n\n  if (parent && !mode) {\n    // If not set explicitly, inherit from the parent describe.\n    _mode = parent.mode;\n  }\n\n  return {\n    type: 'describeBlock',\n    // eslint-disable-next-line sort-keys\n    children: [],\n    hooks: [],\n    mode: _mode,\n    name: (0, _jestUtil.convertDescriptorToString)(name),\n    parent,\n    tests: []\n  };\n};\n\nexports.makeDescribe = makeDescribe;\n\nconst makeTest = (fn, mode, name, parent, timeout, asyncError) => ({\n  type: 'test',\n  // eslint-disable-next-line sort-keys\n  asyncError,\n  duration: null,\n  errors: [],\n  fn,\n  invocations: 0,\n  mode,\n  name: (0, _jestUtil.convertDescriptorToString)(name),\n  parent,\n  seenDone: false,\n  startedAt: null,\n  status: null,\n  timeout\n}); // Traverse the tree of describe blocks and return true if at least one describe\n// block has an enabled test.\n\n\nexports.makeTest = makeTest;\n\nconst hasEnabledTest = describeBlock => {\n  const {\n    hasFocusedTests,\n    testNamePattern\n  } = (0, _state.getState)();\n  return describeBlock.children.some(child => child.type === 'describeBlock' ? hasEnabledTest(child) : !(child.mode === 'skip' || hasFocusedTests && child.mode !== 'only' || testNamePattern && !testNamePattern.test(getTestID(child))));\n};\n\nconst getAllHooksForDescribe = describe => {\n  const result = {\n    afterAll: [],\n    beforeAll: []\n  };\n\n  if (hasEnabledTest(describe)) {\n    for (const hook of describe.hooks) {\n      switch (hook.type) {\n        case 'beforeAll':\n          result.beforeAll.push(hook);\n          break;\n\n        case 'afterAll':\n          result.afterAll.push(hook);\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n\nexports.getAllHooksForDescribe = getAllHooksForDescribe;\n\nconst getEachHooksForTest = test => {\n  const result = {\n    afterEach: [],\n    beforeEach: []\n  };\n  let block = test.parent;\n\n  do {\n    const beforeEachForCurrentBlock = []; // TODO: inline after https://github.com/microsoft/TypeScript/pull/34840 is released\n\n    let hook;\n\n    for (hook of block.hooks) {\n      switch (hook.type) {\n        case 'beforeEach':\n          beforeEachForCurrentBlock.push(hook);\n          break;\n\n        case 'afterEach':\n          result.afterEach.push(hook);\n          break;\n      }\n    } // 'beforeEach' hooks are executed from top to bottom, the opposite of the\n    // way we traversed it.\n\n\n    result.beforeEach = [...beforeEachForCurrentBlock, ...result.beforeEach];\n  } while (block = block.parent);\n\n  return result;\n};\n\nexports.getEachHooksForTest = getEachHooksForTest;\n\nconst describeBlockHasTests = describe => describe.children.some(child => child.type === 'test' || describeBlockHasTests(child));\n\nexports.describeBlockHasTests = describeBlockHasTests;\n\nconst _makeTimeoutMessage = (timeout, isHook) => `Exceeded timeout of ${(0, _jestUtil.formatTime)(timeout)} for a ${isHook ? 'hook' : 'test'}.\\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`; // Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\n\n\nconst {\n  setTimeout,\n  clearTimeout\n} = global;\n\nfunction checkIsError(error) {\n  return !!(error && error.message && error.stack);\n}\n\nconst callAsyncCircusFn = (testOrHook, testContext, _ref) => {\n  let {\n    isHook,\n    timeout\n  } = _ref;\n  let timeoutID;\n  let completed = false;\n  const {\n    fn,\n    asyncError\n  } = testOrHook;\n  return new Promise((resolve, reject) => {\n    timeoutID = setTimeout(() => reject(_makeTimeoutMessage(timeout, isHook)), timeout); // If this fn accepts `done` callback we return a promise that fulfills as\n    // soon as `done` called.\n\n    if (takesDoneCallback(fn)) {\n      let returnedValue = undefined;\n\n      const done = reason => {\n        // We need to keep a stack here before the promise tick\n        const errorAtDone = new _jestUtil.ErrorWithStack(undefined, done);\n\n        if (!completed && testOrHook.seenDone) {\n          errorAtDone.message = 'Expected done to be called once, but it was called multiple times.';\n\n          if (reason) {\n            errorAtDone.message += ' Reason: ' + (0, _prettyFormat.format)(reason, {\n              maxDepth: 3\n            });\n          }\n\n          reject(errorAtDone);\n          throw errorAtDone;\n        } else {\n          testOrHook.seenDone = true;\n        } // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously\n\n\n        Promise.resolve().then(() => {\n          if (returnedValue !== undefined) {\n            asyncError.message = (0, _dedent.default)`\n      Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n      Returned value: ${(0, _prettyFormat.format)(returnedValue, {\n              maxDepth: 3\n            })}\n      `;\n            return reject(asyncError);\n          }\n\n          let errorAsErrorObject;\n\n          if (checkIsError(reason)) {\n            errorAsErrorObject = reason;\n          } else {\n            errorAsErrorObject = errorAtDone;\n            errorAtDone.message = `Failed: ${(0, _prettyFormat.format)(reason, {\n              maxDepth: 3\n            })}`;\n          } // Consider always throwing, regardless if `reason` is set or not\n\n\n          if (completed && reason) {\n            errorAsErrorObject.message = 'Caught error after test environment was torn down\\n\\n' + errorAsErrorObject.message;\n            throw errorAsErrorObject;\n          }\n\n          return reason ? reject(errorAsErrorObject) : resolve();\n        });\n      };\n\n      returnedValue = fn.call(testContext, done);\n      return;\n    }\n\n    let returnedValue;\n\n    if (isGeneratorFunction(fn)) {\n      returnedValue = _co.default.wrap(fn).call({});\n    } else {\n      try {\n        returnedValue = fn.call(testContext);\n      } catch (error) {\n        reject(error);\n        return;\n      }\n    } // If it's a Promise, return it. Test for an object with a `then` function\n    // to support custom Promise implementations.\n\n\n    if (typeof returnedValue === 'object' && returnedValue !== null && typeof returnedValue.then === 'function') {\n      returnedValue.then(() => resolve(), reject);\n      return;\n    }\n\n    if (!isHook && returnedValue !== undefined) {\n      reject(new Error((0, _dedent.default)`\n      test functions can only return Promise or undefined.\n      Returned value: ${(0, _prettyFormat.format)(returnedValue, {\n        maxDepth: 3\n      })}\n      `));\n      return;\n    } // Otherwise this test is synchronous, and if it didn't throw it means\n    // it passed.\n\n\n    resolve();\n  }).then(() => {\n    var _timeoutID$unref, _timeoutID;\n\n    completed = true; // If timeout is not cleared/unrefed the node process won't exit until\n    // it's resolved.\n\n    (_timeoutID$unref = (_timeoutID = timeoutID).unref) === null || _timeoutID$unref === void 0 ? void 0 : _timeoutID$unref.call(_timeoutID);\n    clearTimeout(timeoutID);\n  }).catch(error => {\n    var _timeoutID$unref2, _timeoutID2;\n\n    completed = true;\n    (_timeoutID$unref2 = (_timeoutID2 = timeoutID).unref) === null || _timeoutID$unref2 === void 0 ? void 0 : _timeoutID$unref2.call(_timeoutID2);\n    clearTimeout(timeoutID);\n    throw error;\n  });\n};\n\nexports.callAsyncCircusFn = callAsyncCircusFn;\n\nconst getTestDuration = test => {\n  const {\n    startedAt\n  } = test;\n  return typeof startedAt === 'number' ? jestNow() - startedAt : null;\n};\n\nexports.getTestDuration = getTestDuration;\n\nconst makeRunResult = (describeBlock, unhandledErrors) => ({\n  testResults: makeTestResults(describeBlock),\n  unhandledErrors: unhandledErrors.map(_getError).map(getErrorStack)\n});\n\nexports.makeRunResult = makeRunResult;\n\nconst makeSingleTestResult = test => {\n  const {\n    includeTestLocationInResult\n  } = (0, _state.getState)();\n  const testPath = [];\n  let parent = test;\n  const {\n    status\n  } = test;\n  invariant(status, 'Status should be present after tests are run.');\n\n  do {\n    testPath.unshift(parent.name);\n  } while (parent = parent.parent);\n\n  let location = null;\n\n  if (includeTestLocationInResult) {\n    var _parsedLine, _parsedLine$file;\n\n    const stackLines = test.asyncError.stack.split('\\n');\n    const stackLine = stackLines[1];\n    let parsedLine = stackUtils.parseLine(stackLine);\n\n    if ((_parsedLine = parsedLine) !== null && _parsedLine !== void 0 && (_parsedLine$file = _parsedLine.file) !== null && _parsedLine$file !== void 0 && _parsedLine$file.startsWith(jestEachBuildDir)) {\n      const stackLine = stackLines[4];\n      parsedLine = stackUtils.parseLine(stackLine);\n    }\n\n    if (parsedLine && typeof parsedLine.column === 'number' && typeof parsedLine.line === 'number') {\n      location = {\n        column: parsedLine.column,\n        line: parsedLine.line\n      };\n    }\n  }\n\n  const errorsDetailed = test.errors.map(_getError);\n  return {\n    duration: test.duration,\n    errors: errorsDetailed.map(getErrorStack),\n    errorsDetailed,\n    invocations: test.invocations,\n    location,\n    status,\n    testPath: Array.from(testPath)\n  };\n};\n\nexports.makeSingleTestResult = makeSingleTestResult;\n\nconst makeTestResults = describeBlock => {\n  const testResults = [];\n\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        {\n          testResults.push(...makeTestResults(child));\n          break;\n        }\n\n      case 'test':\n        {\n          testResults.push(makeSingleTestResult(child));\n          break;\n        }\n    }\n  }\n\n  return testResults;\n}; // Return a string that identifies the test (concat of parent describe block\n// names + test title)\n\n\nconst getTestID = test => {\n  const titles = [];\n  let parent = test;\n\n  do {\n    titles.unshift(parent.name);\n  } while (parent = parent.parent);\n\n  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME\n\n  return titles.join(' ');\n};\n\nexports.getTestID = getTestID;\n\nconst _getError = errors => {\n  let error;\n  let asyncError;\n\n  if (Array.isArray(errors)) {\n    error = errors[0];\n    asyncError = errors[1];\n  } else {\n    error = errors;\n    asyncError = new Error();\n  }\n\n  if (error && (typeof error.stack === 'string' || error.message)) {\n    return error;\n  }\n\n  asyncError.message = `thrown: ${(0, _prettyFormat.format)(error, {\n    maxDepth: 3\n  })}`;\n  return asyncError;\n};\n\nconst getErrorStack = error => typeof error.stack === 'string' ? error.stack : error.message;\n\nconst addErrorToEachTestUnderDescribe = (describeBlock, error, asyncError) => {\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        addErrorToEachTestUnderDescribe(child, error, asyncError);\n        break;\n\n      case 'test':\n        child.errors.push([error, asyncError]);\n        break;\n    }\n  }\n};\n\nexports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst parseSingleTestResult = testResult => {\n  let status;\n\n  if (testResult.status === 'skip') {\n    status = 'pending';\n  } else if (testResult.status === 'todo') {\n    status = 'todo';\n  } else if (testResult.errors.length > 0) {\n    status = 'failed';\n  } else {\n    status = 'passed';\n  }\n\n  const ancestorTitles = testResult.testPath.filter(name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME);\n  const title = ancestorTitles.pop();\n  return {\n    ancestorTitles,\n    duration: testResult.duration,\n    failureDetails: testResult.errorsDetailed,\n    failureMessages: Array.from(testResult.errors),\n    fullName: title ? ancestorTitles.concat(title).join(' ') : ancestorTitles.join(' '),\n    invocations: testResult.invocations,\n    location: testResult.location,\n    numPassingAsserts: 0,\n    status,\n    title: testResult.testPath[testResult.testPath.length - 1]\n  };\n};\n\nexports.parseSingleTestResult = parseSingleTestResult;","map":{"version":3,"sources":["/Users/awaraamin/2020/The-complete-2020-Web-Development-Bootcamp/practice/react/amazona/frontend/node_modules/jest-circus/build/utils.js"],"names":["Object","defineProperty","exports","value","getTestID","getTestDuration","getEachHooksForTest","getAllHooksForDescribe","describeBlockHasTests","callAsyncCircusFn","addErrorToEachTestUnderDescribe","invariant","parseSingleTestResult","makeTest","makeSingleTestResult","makeRunResult","makeDescribe","path","_interopRequireWildcard","require","_co","_interopRequireDefault","_dedent","_isGeneratorFn","_slash","_stackUtils","_jestUtil","_prettyFormat","_state","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","global","globalThis","self","window","Function","Symbol","jestNow","for","Date","now","Promise","stackUtils","cwd","jestEachBuildDir","dirname","resolve","takesDoneCallback","fn","length","isGeneratorFunction","name","parent","mode","_mode","type","children","hooks","convertDescriptorToString","tests","timeout","asyncError","duration","errors","invocations","seenDone","startedAt","status","hasEnabledTest","describeBlock","hasFocusedTests","testNamePattern","getState","some","child","test","describe","result","afterAll","beforeAll","hook","push","afterEach","beforeEach","block","beforeEachForCurrentBlock","_makeTimeoutMessage","isHook","formatTime","setTimeout","clearTimeout","checkIsError","error","message","stack","testOrHook","testContext","timeoutID","completed","reject","returnedValue","undefined","done","reason","errorAtDone","ErrorWithStack","format","maxDepth","then","errorAsErrorObject","wrap","Error","_timeoutID$unref","_timeoutID","unref","catch","_timeoutID$unref2","_timeoutID2","unhandledErrors","testResults","makeTestResults","map","_getError","getErrorStack","includeTestLocationInResult","testPath","unshift","location","_parsedLine","_parsedLine$file","stackLines","split","stackLine","parsedLine","parseLine","file","startsWith","column","line","errorsDetailed","Array","from","titles","shift","join","isArray","condition","testResult","ancestorTitles","filter","ROOT_DESCRIBE_BLOCK_NAME","title","pop","failureDetails","failureMessages","fullName","concat","numPassingAsserts"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getTestID =\n  exports.getTestDuration =\n  exports.getEachHooksForTest =\n  exports.getAllHooksForDescribe =\n  exports.describeBlockHasTests =\n  exports.callAsyncCircusFn =\n  exports.addErrorToEachTestUnderDescribe =\n    void 0;\nexports.invariant = invariant;\nexports.parseSingleTestResult =\n  exports.makeTest =\n  exports.makeSingleTestResult =\n  exports.makeRunResult =\n  exports.makeDescribe =\n    void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _dedent = _interopRequireDefault(require('dedent'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _jestUtil = require('jest-util');\n\nvar _prettyFormat = require('pretty-format');\n\nvar _state = require('./state');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\nconst stackUtils = new _stackUtils.default({\n  cwd: 'A path that does not exist'\n});\nconst jestEachBuildDir = (0, _slash.default)(\n  path.dirname(require.resolve('jest-each'))\n);\n\nfunction takesDoneCallback(fn) {\n  return fn.length > 0;\n}\n\nfunction isGeneratorFunction(fn) {\n  return (0, _isGeneratorFn.default)(fn);\n}\n\nconst makeDescribe = (name, parent, mode) => {\n  let _mode = mode;\n\n  if (parent && !mode) {\n    // If not set explicitly, inherit from the parent describe.\n    _mode = parent.mode;\n  }\n\n  return {\n    type: 'describeBlock',\n    // eslint-disable-next-line sort-keys\n    children: [],\n    hooks: [],\n    mode: _mode,\n    name: (0, _jestUtil.convertDescriptorToString)(name),\n    parent,\n    tests: []\n  };\n};\n\nexports.makeDescribe = makeDescribe;\n\nconst makeTest = (fn, mode, name, parent, timeout, asyncError) => ({\n  type: 'test',\n  // eslint-disable-next-line sort-keys\n  asyncError,\n  duration: null,\n  errors: [],\n  fn,\n  invocations: 0,\n  mode,\n  name: (0, _jestUtil.convertDescriptorToString)(name),\n  parent,\n  seenDone: false,\n  startedAt: null,\n  status: null,\n  timeout\n}); // Traverse the tree of describe blocks and return true if at least one describe\n// block has an enabled test.\n\nexports.makeTest = makeTest;\n\nconst hasEnabledTest = describeBlock => {\n  const {hasFocusedTests, testNamePattern} = (0, _state.getState)();\n  return describeBlock.children.some(child =>\n    child.type === 'describeBlock'\n      ? hasEnabledTest(child)\n      : !(\n          child.mode === 'skip' ||\n          (hasFocusedTests && child.mode !== 'only') ||\n          (testNamePattern && !testNamePattern.test(getTestID(child)))\n        )\n  );\n};\n\nconst getAllHooksForDescribe = describe => {\n  const result = {\n    afterAll: [],\n    beforeAll: []\n  };\n\n  if (hasEnabledTest(describe)) {\n    for (const hook of describe.hooks) {\n      switch (hook.type) {\n        case 'beforeAll':\n          result.beforeAll.push(hook);\n          break;\n\n        case 'afterAll':\n          result.afterAll.push(hook);\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n\nexports.getAllHooksForDescribe = getAllHooksForDescribe;\n\nconst getEachHooksForTest = test => {\n  const result = {\n    afterEach: [],\n    beforeEach: []\n  };\n  let block = test.parent;\n\n  do {\n    const beforeEachForCurrentBlock = []; // TODO: inline after https://github.com/microsoft/TypeScript/pull/34840 is released\n\n    let hook;\n\n    for (hook of block.hooks) {\n      switch (hook.type) {\n        case 'beforeEach':\n          beforeEachForCurrentBlock.push(hook);\n          break;\n\n        case 'afterEach':\n          result.afterEach.push(hook);\n          break;\n      }\n    } // 'beforeEach' hooks are executed from top to bottom, the opposite of the\n    // way we traversed it.\n\n    result.beforeEach = [...beforeEachForCurrentBlock, ...result.beforeEach];\n  } while ((block = block.parent));\n\n  return result;\n};\n\nexports.getEachHooksForTest = getEachHooksForTest;\n\nconst describeBlockHasTests = describe =>\n  describe.children.some(\n    child => child.type === 'test' || describeBlockHasTests(child)\n  );\n\nexports.describeBlockHasTests = describeBlockHasTests;\n\nconst _makeTimeoutMessage = (timeout, isHook) =>\n  `Exceeded timeout of ${(0, _jestUtil.formatTime)(timeout)} for a ${\n    isHook ? 'hook' : 'test'\n  }.\\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`; // Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\n\nconst {setTimeout, clearTimeout} = global;\n\nfunction checkIsError(error) {\n  return !!(error && error.message && error.stack);\n}\n\nconst callAsyncCircusFn = (testOrHook, testContext, {isHook, timeout}) => {\n  let timeoutID;\n  let completed = false;\n  const {fn, asyncError} = testOrHook;\n  return new Promise((resolve, reject) => {\n    timeoutID = setTimeout(\n      () => reject(_makeTimeoutMessage(timeout, isHook)),\n      timeout\n    ); // If this fn accepts `done` callback we return a promise that fulfills as\n    // soon as `done` called.\n\n    if (takesDoneCallback(fn)) {\n      let returnedValue = undefined;\n\n      const done = reason => {\n        // We need to keep a stack here before the promise tick\n        const errorAtDone = new _jestUtil.ErrorWithStack(undefined, done);\n\n        if (!completed && testOrHook.seenDone) {\n          errorAtDone.message =\n            'Expected done to be called once, but it was called multiple times.';\n\n          if (reason) {\n            errorAtDone.message +=\n              ' Reason: ' +\n              (0, _prettyFormat.format)(reason, {\n                maxDepth: 3\n              });\n          }\n\n          reject(errorAtDone);\n          throw errorAtDone;\n        } else {\n          testOrHook.seenDone = true;\n        } // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously\n\n        Promise.resolve().then(() => {\n          if (returnedValue !== undefined) {\n            asyncError.message = (0, _dedent.default)`\n      Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n      Returned value: ${(0, _prettyFormat.format)(returnedValue, {\n        maxDepth: 3\n      })}\n      `;\n            return reject(asyncError);\n          }\n\n          let errorAsErrorObject;\n\n          if (checkIsError(reason)) {\n            errorAsErrorObject = reason;\n          } else {\n            errorAsErrorObject = errorAtDone;\n            errorAtDone.message = `Failed: ${(0, _prettyFormat.format)(reason, {\n              maxDepth: 3\n            })}`;\n          } // Consider always throwing, regardless if `reason` is set or not\n\n          if (completed && reason) {\n            errorAsErrorObject.message =\n              'Caught error after test environment was torn down\\n\\n' +\n              errorAsErrorObject.message;\n            throw errorAsErrorObject;\n          }\n\n          return reason ? reject(errorAsErrorObject) : resolve();\n        });\n      };\n\n      returnedValue = fn.call(testContext, done);\n      return;\n    }\n\n    let returnedValue;\n\n    if (isGeneratorFunction(fn)) {\n      returnedValue = _co.default.wrap(fn).call({});\n    } else {\n      try {\n        returnedValue = fn.call(testContext);\n      } catch (error) {\n        reject(error);\n        return;\n      }\n    } // If it's a Promise, return it. Test for an object with a `then` function\n    // to support custom Promise implementations.\n\n    if (\n      typeof returnedValue === 'object' &&\n      returnedValue !== null &&\n      typeof returnedValue.then === 'function'\n    ) {\n      returnedValue.then(() => resolve(), reject);\n      return;\n    }\n\n    if (!isHook && returnedValue !== undefined) {\n      reject(\n        new Error((0, _dedent.default)`\n      test functions can only return Promise or undefined.\n      Returned value: ${(0, _prettyFormat.format)(returnedValue, {\n        maxDepth: 3\n      })}\n      `)\n      );\n      return;\n    } // Otherwise this test is synchronous, and if it didn't throw it means\n    // it passed.\n\n    resolve();\n  })\n    .then(() => {\n      var _timeoutID$unref, _timeoutID;\n\n      completed = true; // If timeout is not cleared/unrefed the node process won't exit until\n      // it's resolved.\n\n      (_timeoutID$unref = (_timeoutID = timeoutID).unref) === null ||\n      _timeoutID$unref === void 0\n        ? void 0\n        : _timeoutID$unref.call(_timeoutID);\n      clearTimeout(timeoutID);\n    })\n    .catch(error => {\n      var _timeoutID$unref2, _timeoutID2;\n\n      completed = true;\n      (_timeoutID$unref2 = (_timeoutID2 = timeoutID).unref) === null ||\n      _timeoutID$unref2 === void 0\n        ? void 0\n        : _timeoutID$unref2.call(_timeoutID2);\n      clearTimeout(timeoutID);\n      throw error;\n    });\n};\n\nexports.callAsyncCircusFn = callAsyncCircusFn;\n\nconst getTestDuration = test => {\n  const {startedAt} = test;\n  return typeof startedAt === 'number' ? jestNow() - startedAt : null;\n};\n\nexports.getTestDuration = getTestDuration;\n\nconst makeRunResult = (describeBlock, unhandledErrors) => ({\n  testResults: makeTestResults(describeBlock),\n  unhandledErrors: unhandledErrors.map(_getError).map(getErrorStack)\n});\n\nexports.makeRunResult = makeRunResult;\n\nconst makeSingleTestResult = test => {\n  const {includeTestLocationInResult} = (0, _state.getState)();\n  const testPath = [];\n  let parent = test;\n  const {status} = test;\n  invariant(status, 'Status should be present after tests are run.');\n\n  do {\n    testPath.unshift(parent.name);\n  } while ((parent = parent.parent));\n\n  let location = null;\n\n  if (includeTestLocationInResult) {\n    var _parsedLine, _parsedLine$file;\n\n    const stackLines = test.asyncError.stack.split('\\n');\n    const stackLine = stackLines[1];\n    let parsedLine = stackUtils.parseLine(stackLine);\n\n    if (\n      (_parsedLine = parsedLine) !== null &&\n      _parsedLine !== void 0 &&\n      (_parsedLine$file = _parsedLine.file) !== null &&\n      _parsedLine$file !== void 0 &&\n      _parsedLine$file.startsWith(jestEachBuildDir)\n    ) {\n      const stackLine = stackLines[4];\n      parsedLine = stackUtils.parseLine(stackLine);\n    }\n\n    if (\n      parsedLine &&\n      typeof parsedLine.column === 'number' &&\n      typeof parsedLine.line === 'number'\n    ) {\n      location = {\n        column: parsedLine.column,\n        line: parsedLine.line\n      };\n    }\n  }\n\n  const errorsDetailed = test.errors.map(_getError);\n  return {\n    duration: test.duration,\n    errors: errorsDetailed.map(getErrorStack),\n    errorsDetailed,\n    invocations: test.invocations,\n    location,\n    status,\n    testPath: Array.from(testPath)\n  };\n};\n\nexports.makeSingleTestResult = makeSingleTestResult;\n\nconst makeTestResults = describeBlock => {\n  const testResults = [];\n\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock': {\n        testResults.push(...makeTestResults(child));\n        break;\n      }\n\n      case 'test': {\n        testResults.push(makeSingleTestResult(child));\n        break;\n      }\n    }\n  }\n\n  return testResults;\n}; // Return a string that identifies the test (concat of parent describe block\n// names + test title)\n\nconst getTestID = test => {\n  const titles = [];\n  let parent = test;\n\n  do {\n    titles.unshift(parent.name);\n  } while ((parent = parent.parent));\n\n  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME\n\n  return titles.join(' ');\n};\n\nexports.getTestID = getTestID;\n\nconst _getError = errors => {\n  let error;\n  let asyncError;\n\n  if (Array.isArray(errors)) {\n    error = errors[0];\n    asyncError = errors[1];\n  } else {\n    error = errors;\n    asyncError = new Error();\n  }\n\n  if (error && (typeof error.stack === 'string' || error.message)) {\n    return error;\n  }\n\n  asyncError.message = `thrown: ${(0, _prettyFormat.format)(error, {\n    maxDepth: 3\n  })}`;\n  return asyncError;\n};\n\nconst getErrorStack = error =>\n  typeof error.stack === 'string' ? error.stack : error.message;\n\nconst addErrorToEachTestUnderDescribe = (describeBlock, error, asyncError) => {\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        addErrorToEachTestUnderDescribe(child, error, asyncError);\n        break;\n\n      case 'test':\n        child.errors.push([error, asyncError]);\n        break;\n    }\n  }\n};\n\nexports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst parseSingleTestResult = testResult => {\n  let status;\n\n  if (testResult.status === 'skip') {\n    status = 'pending';\n  } else if (testResult.status === 'todo') {\n    status = 'todo';\n  } else if (testResult.errors.length > 0) {\n    status = 'failed';\n  } else {\n    status = 'passed';\n  }\n\n  const ancestorTitles = testResult.testPath.filter(\n    name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME\n  );\n  const title = ancestorTitles.pop();\n  return {\n    ancestorTitles,\n    duration: testResult.duration,\n    failureDetails: testResult.errorsDetailed,\n    failureMessages: Array.from(testResult.errors),\n    fullName: title\n      ? ancestorTitles.concat(title).join(' ')\n      : ancestorTitles.join(' '),\n    invocations: testResult.invocations,\n    location: testResult.location,\n    numPassingAsserts: 0,\n    status,\n    title: testResult.testPath[testResult.testPath.length - 1]\n  };\n};\n\nexports.parseSingleTestResult = parseSingleTestResult;\n"]},"metadata":{},"sourceType":"script"}